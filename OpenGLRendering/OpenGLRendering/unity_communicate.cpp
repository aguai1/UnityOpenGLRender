/*
与Unity通信的C++层接口。先默认是Opengl core的图形库。
包含几个接口函数：
1、传递时间参数t;
2、传递mesh的坐标数组；
。
。
。

OpenGL渲染的流程，通过查看官方一个渲染三角形的例子来入手。

*/
#include <stddef.h>
#include<assert.h>
#include"Unity\IUnityGraphics.h"
#include"GLEW\glew.h"
#include"PlatformBase.h"
#include<math.h>
//#include"Debug.h"
#include"ShaderResource.hpp"
#include<vector>
#include"MyDebug.hpp"

using namespace std;

enum VertexInputs
{
	kVertexInputPosition = 0,
	kVertexInputColor = 1
};

struct VertexPosition
{
	float x;
	float y;
	float z;
};

//UnityGfxRenderer m_APIType;

GLuint m_VertexShader;
GLuint m_FragmentShader;

//shader程序
GLuint m_Program;

//顶点数组
GLuint m_VertexArray;
//顶点缓存，还要看一下在哪里用
GLuint m_VertexBuffer;
//索引缓存
GLuint m_IndexBuffer;

//下面两个变量分别是worldMatrix和projMatrix在shader中的位置。
int m_UniformWorldMatrix;
int m_UniformProjMatrix;

int m_UniformMVPMatrix;
int m_UniformCoeff;

UnityGfxRenderer apiType;

//在shader中做坐标转换的MVP矩阵。
float mvpMatrix[16];

float g_Time;

//插值的系数，它等于(Time.time - curTimes) / interval。通过Unity端传过来。
float interpolateCoeff;

//顶点数据不是以Vector3的形式存储，而是以float的形式存储，这个有点意外。
float* vertexArray;
int*   indexArray;

int vertexLength;
int indicesLength;

//// Simple vertex shader source
//#define VERTEX_SHADER_SRC(ver, attr, varying)						\
//	ver																\
//	attr " highp vec3 pos;\n"										\
//	attr " lowp vec4 color;\n"										\
//	"\n"															\
//	varying " lowp vec4 ocolor;\n"									\
//	"\n"															\
//	"uniform highp mat4 worldMatrix;\n"								\
//	"uniform highp mat4 projMatrix;\n"								\
//	"uniform highp mat4 mvpMatrix;\n"								\
//	"\n"															\
//	"void main()\n"													\
//	"{\n"															\
//	"	//gl_Position = (projMatrix * worldMatrix) * vec4(pos,1);\n"\
//	"	gl_Position = mvpMatrix * vec4(pos,1);\n"\
//	"	ocolor = color;\n"											\
//	"}\n"															\
//
//// Simple fragment shader source
//#define FRAGMENT_SHADER_SRC(ver, varying, outDecl, outVar)	\
//	ver												\
//	outDecl											\
//	varying " lowp vec4 ocolor;\n"					\
//	"\n"											\
//	"void main()\n"									\
//	"{\n"											\
//	"	" outVar " = ocolor;\n"						\
//	"}\n"											\

//创建Vertex和Fragment shader.
static const char* kGlesVProgTextGLES2 = VERTEX_SHADER_SRC("\n", "attribute", "varying");
static const char* kGlesVProgTextGLES3 = VERTEX_SHADER_SRC("#version 300 es\n", "in", "out");
#if SUPPORT_OPENGL_CORE
static const char* kGlesVProgTextGLCore = VERTEX_SHADER_SRC("#version 150\n", "in", "out");
#endif

static const char* kGlesFShaderTextGLES2 = FRAGMENT_SHADER_SRC("\n", "varying", "\n", "gl_FragColor");
static const char* kGlesFShaderTextGLES3 = FRAGMENT_SHADER_SRC("#version 300 es\n", "in", "out lowp vec4 fragColor;\n", "fragColor");
#if SUPPORT_OPENGL_CORE
static const char* kGlesFShaderTextGLCore = FRAGMENT_SHADER_SRC("#version 150\n", "in", "out lowp vec4 fragColor;\n", "fragColor");
#endif

//type specify whether it is a vertex or fragment shader.
static GLuint CreateShader(GLenum type, const char* sourceText)
{
	GLuint ret = glCreateShader(type);
	glShaderSource(ret, 1, &sourceText, NULL);
	glCompileShader(ret);
	return ret;
}

//创建OpenGL资源,在一开始的时候调用。可以在Start里，也可以放到OnPluginLoad事件里。
static void CreateResources()
{
	// Create shaders
	//假定Graphics api就是OpenGLES2.0
	if (apiType == kUnityGfxRendererOpenGLES20)
	{
		m_VertexShader = CreateShader(GL_VERTEX_SHADER, kGlesVProgTextGLES2);
		m_FragmentShader = CreateShader(GL_FRAGMENT_SHADER, kGlesFShaderTextGLES2);
	}
	else if (apiType == kUnityGfxRendererOpenGLES30)
	{
		m_VertexShader = CreateShader(GL_VERTEX_SHADER, kGlesVProgTextGLES3);
		m_FragmentShader = CreateShader(GL_FRAGMENT_SHADER, kGlesFShaderTextGLES3);
	}
#	if SUPPORT_OPENGL_CORE
	//假定render api就是OpenGLCore
	else if (apiType == kUnityGfxRendererOpenGLCore)
	{
		glewExperimental = GL_TRUE;
		glewInit();
		glGetError(); // Clean up error generated by glewInit

		m_VertexShader = CreateShader(GL_VERTEX_SHADER, kGlesVProgTextGLCore);
		m_FragmentShader = CreateShader(GL_FRAGMENT_SHADER, kGlesFShaderTextGLCore);
	}
#	endif // if SUPPORT_OPENGL_CORE
	//Debug::GetInst()->Log("Create shader success.\r\n");

	// Link shaders into a program and find uniform locations
	m_Program = glCreateProgram();
	if (m_Program != 0)
		FileDebug::Log("Shader program not null.");
		//Debug::GetInst()->Log("Shader program not null.\r\n");
	glBindAttribLocation(m_Program, kVertexInputPosition, "pos");
	glBindAttribLocation(m_Program, kVertexInputColor, "color");
	glAttachShader(m_Program, m_VertexShader);
	glAttachShader(m_Program, m_FragmentShader);
#	if SUPPORT_OPENGL_CORE
	if (apiType == kUnityGfxRendererOpenGLCore)
		glBindFragDataLocation(m_Program, 0, "fragColor");
#	endif // if SUPPORT_OPENGL_CORE
	glLinkProgram(m_Program);

	GLint status = 0;
	glGetProgramiv(m_Program, GL_LINK_STATUS, &status);
	assert(status == GL_TRUE);

	//获取到shader中变量的位置
	//Get location of variable in shader.
	m_UniformWorldMatrix = glGetUniformLocation(m_Program, "worldMatrix");
	m_UniformProjMatrix = glGetUniformLocation(m_Program, "projMatrix");

	m_UniformMVPMatrix = glGetUniformLocation(m_Program, "mvpMatrix");

	m_UniformCoeff = glGetUniformLocation(m_Program, "coeff");

	// Create vertex buffer
	glGenBuffers(1, &m_VertexBuffer);
	glBindBuffer(GL_ARRAY_BUFFER, m_VertexBuffer);
	glBufferData(GL_ARRAY_BUFFER, vertexLength*sizeof(float), vertexArray, GL_STREAM_DRAW);

	//创建索引缓存
	glGenBuffers(1, &m_IndexBuffer);
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_IndexBuffer);
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesLength*sizeof(int), indexArray, GL_STREAM_DRAW);

	assert(glGetError() == GL_NO_ERROR);
}

//每帧都要执行的函数
//static void DrawSimpleTriangles(const float worldMatrix[16], int triangleCount, const void* verticesFloat3Byte4,const void* indices)
static void DrawSimpleTriangles()//int triangleCount, const void* verticesFloat3Byte4, const void* indices)
{
	// Set basic render state
	glDisable(GL_CULL_FACE);
	glDisable(GL_BLEND);
	//相当于Unity中的ZTest
	glDepthFunc(GL_LEQUAL);
	glEnable(GL_DEPTH_TEST);
	glDepthMask(GL_FALSE);

	//// Tweak the projection matrix a bit to make it match what identity projection would do in D3D case.
	//float projectionMatrix[16] = {
	//	1,0,0,0,
	//	0,1,0,0,
	//	0,0,2,0,
	//	0,0,-1,1,
	//};

	// Setup shader program to use, and the matrices
	glUseProgram(m_Program);
	//glUniformMatrix4fv(m_UniformWorldMatrix, 1, GL_FALSE, worldMatrix);
	//glUniformMatrix4fv(m_UniformProjMatrix, 1, GL_FALSE, projectionMatrix);

	glUniformMatrix4fv(m_UniformMVPMatrix, 1, GL_FALSE, mvpMatrix);
	glUniform1f(m_UniformCoeff, interpolateCoeff);

	// Core profile needs VAOs, setup one
#	if SUPPORT_OPENGL_CORE
	if (apiType == kUnityGfxRendererOpenGLCore)
	{
		glGenVertexArrays(1, &m_VertexArray);
		//绑定这个vertex_array之后，后面的操作都与这个vertex_array相关
		glBindVertexArray(m_VertexArray);
	}
#	endif // if SUPPORT_OPENGL_CORE

	// Bind a vertex buffer, and update data in it
	const int kVertexSize = 12;// +4;
							   ////索引数据
							   //glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_IndexBuffer);
							   //glBufferData(GL_ELEMENT_ARRAY_BUFFER, sizeof(indexArray), indexArray, GL_STREAM_DRAW);
							   //顶点数据
	glBindBuffer(GL_ARRAY_BUFFER, m_VertexBuffer);
	glBufferData(GL_ARRAY_BUFFER, vertexLength, vertexArray, GL_STREAM_DRAW);
	//glBufferSubData(GL_ARRAY_BUFFER, 0, kVertexSize * triangleCount * 3, verticesFloat3Byte4);
	//glBufferSubData(GL_ARRAY_BUFFER, 0, sizeof(vertexArray), vertexArray);

	// Setup vertex layout
	//下面的几句话，操作的数组是在glBindBuffer中设置GL_ARRAY_BUFFER设定的。
	glEnableVertexAttribArray(kVertexInputPosition);
	//给shader中传递Position。
	//最后一个参数是指偏移量，因为只有这一个数组，所以偏移量为0.
	glVertexAttribPointer(kVertexInputPosition, 3, GL_FLOAT, GL_FALSE, 3 * sizeof(float), (char*)0);
	//glEnableVertexAttribArray(kVertexInputColor);
	//glVertexAttribPointer(kVertexInputColor, 4, GL_UNSIGNED_BYTE, GL_TRUE, kVertexSize, (char*)NULL + 12);

	// Draw
	//第一个参数：三角形的形态，第二个参数，
	glDrawElements(GL_TRIANGLES, indicesLength, GL_UNSIGNED_INT, indexArray);
	//glDrawArrays(GL_TRIANGLES, 0, triangleCount * 3);

	// Cleanup VAO
#	if SUPPORT_OPENGL_CORE
	if (apiType == kUnityGfxRendererOpenGLCore)
	{
		glDeleteVertexArrays(1, &m_VertexArray);
	}
#	endif
}

static void UNITY_INTERFACE_API OnRenderEvent(int eventID)
{
	// Unknown / unsupported graphics device type? Do nothing
	//if (s_CurrentAPI == NULL)
	//	return;
	if (eventID == 100)
	{
		//CreateResources();
	}
	else if (eventID == 101)
		DrawSimpleTriangles();
	//DrawColoredTriangle();
	//ModifyTexturePixels();
	//ModifyVertexBuffer();
}

extern "C" _declspec(dllexport) void SetTime(float t)
{
	g_Time = t;
}

extern "C" _declspec(dllexport) void SetMVPMatrix(float* _mvpMatrix, int length)
{
	//Debug::GetInst()->Log("sizeof MVPMatrix:%d. \n", sizeof(_mvpMatrix));
	//int len = sizeof(_mvpMatrix) / sizeof(_mvpMatrix[0]);
	//Debug::GetInst()->Log("Length:%d. \n", length);
	for (int i = 0; i < length; i++)
	{
		mvpMatrix[i] = _mvpMatrix[i];
		//Debug::GetInst()->Log("%f ,",mvpMatrix[i]);
	}
	//Debug::GetInst()->Log("\n");
}

//在一开始就要将Mesh信息传过来
extern "C" _declspec(dllexport) void SetMeshInfo(float* _vertexArray, int vertLen, int* _indexArray, int idxLen)
{
	//Debug::GetInst()->Log("进入SetMeshInfo函数");
	FileDebug::Log("进入SetMeshInfo函数");
	vertexArray = new float[vertLen];
	for (int i = 0; i < vertLen; i++)
	{
		vertexArray[i] = _vertexArray[i];
		//Debug::GetInst()->Log("%f ,",mvpMatrix[i]);
	}
	FileDebug::Log("获取到顶点数组");
	//Debug::GetInst()->Log("获取到顶点数组.\n");
	indexArray = new int[idxLen];
	for (int i = 0; i < idxLen; i++)
	{
		indexArray[i] = _indexArray[i];
	}
	vertexLength = vertLen;
	indicesLength = idxLen;
	//sizeof(vertexArray)是指针的长度，并不是数组的长度。
	//Debug::GetInst()->Log("vertex array length:%d.\n",sizeof(vertexArray));

	//一旦Mesh信息传过来之后就可以绑定VBO、EBO了。
	//索引数据
	glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_IndexBuffer);
	//GL_STATIC_DRAW与GL_STREAM_DRAW的区别在于：STATIC，一次修改，多次使用；STREAM 一次修改，少数次使用；DYNAMIC 重复修改，多次使用
	glBufferData(GL_ELEMENT_ARRAY_BUFFER, indicesLength, indexArray, GL_STATIC_DRAW);
}

extern "C" void	UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API UnityPluginLoad(IUnityInterfaces* unityInterfaces)
{
	//在Unity加载dll的时候，会将图形库的接口传过来，这样就知道用的是哪个图形库了。
	//s_UnityInterfaces = unityInterfaces;
	IUnityGraphics* s_Graphics = unityInterfaces->Get<IUnityGraphics>();
	//s_Graphics->RegisterDeviceEventCallback(OnGraphicsDeviceEvent);

	//初始化图形库。
	// Run OnGraphicsDeviceEvent(initialize) manually on plugin load
	//OnGraphicsDeviceEvent(kUnityGfxDeviceEventInitialize);

	//初始化Debug类。
	//Debug::GetInst()->CreatLogFile("debug.log");

	//assert(s_CurrentAPI == NULL);
	apiType = s_Graphics->GetRenderer();
	//Debug::GetInst()->Log("获取Unity GraphicsAPI:%d.\r\n", apiType);
	CreateResources();
	//s_CurrentAPI = CreateRenderAPI(s_DeviceType);



	//#	if SUPPORT_OPENGL_UNIFIED
	//	if (apiType == kUnityGfxRendererOpenGLCore || apiType == kUnityGfxRendererOpenGLES20 || apiType == kUnityGfxRendererOpenGLES30)
	//	{
	//		extern RenderAPI* CreateRenderAPI_OpenGLCoreES(UnityGfxRenderer apiType);
	//		return CreateRenderAPI_OpenGLCoreES(apiType);
	//	}
	//#	endif // if SUPPORT_OPENGL_UNIFIED
}

// --------------------------------------------------------------------------
// GetRenderEventFunc, an example function we export which is used to get a rendering event callback function.

extern "C" UnityRenderingEvent UNITY_INTERFACE_EXPORT UNITY_INTERFACE_API GetRenderEventFunc()
{
	return OnRenderEvent;
}
